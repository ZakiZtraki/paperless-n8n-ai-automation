{
  "name": "Paperless AI Processing",
  "nodes": [
    {
      "parameters": {
        "jsCode": "// Consolidated AI Results Processor - Handles all processing in one node\nconsole.log('=== CONSOLIDATED AI RESULTS PROCESSOR ===');\nconst startTime = Date.now();\n\nlet aiResults = {};\nlet processingErrors = [];\n\ntry {\n  const input = $input.first();\n  if (!input || !input.json) {\n    throw new Error('No input data received');\n  }\n  \n  console.log('Input structure - Keys:', Object.keys(input.json));\n  \n  // Capture document_id from input (single extraction)\n  const documentId = input.json.document_id || null;\n  console.log('Document ID:', documentId);\n  \n  // Extract AI response from \"output\" field\n  let aiResponseText = input.json.output || input.json;\n  console.log('Content type:', typeof aiResponseText);\n  \n  // Parse the AI response\n  let parsedResults;\n  \n  if (typeof aiResponseText === 'object') {\n    parsedResults = aiResponseText;\n  } else if (typeof aiResponseText === 'string') {\n    // Remove markdown code blocks\n    let jsonText = aiResponseText\n      .replace(/```json\\n?/g, '')\n      .replace(/```\\n?/g, '')\n      .trim();\n    \n    parsedResults = JSON.parse(jsonText);\n    console.log('‚úÖ Parsed successfully');\n  }\n  \n  aiResults = parsedResults;\n  \n} catch (error) {\n  console.error('Error:', error.message);\n  processingErrors.push(`Parsing error: ${error.message}`);\n  aiResults = {\n    document_analysis: { confidence: 0.1, category: 'unknown', summary: 'Parsing failed' },\n    document_type: { recommended_id: null, confidence: 0, create_new: false },\n    custom_fields: { field_updates: {}, confidence: 0 },\n    tags: { existing_tag_names: [], new_tags_needed: [], confidence: 0 }\n  };\n}\n\n// Get document_id from input\nconst input = $input.first();\nconst documentId = input?.json?.document_id || null;\n\n// Build final sanitized structure\nconst sanitizedResults = {\n  document_id: documentId,\n  \n  document_analysis: {\n    confidence: Number(aiResults.document_analysis?.confidence) || 0.5,\n    category: String(aiResults.document_analysis?.category || 'unknown'),\n    summary: String(aiResults.document_analysis?.summary || 'Analysis completed')\n  },\n  \n  document_type: {\n    recommended_id: aiResults.document_type?.recommended_id || null,\n    recommended_name: String(aiResults.document_type?.recommended_name || ''),\n    confidence: Number(aiResults.document_type?.confidence) || 0,\n    create_new: Boolean(aiResults.document_type?.create_new),\n    new_type_suggestion: aiResults.document_type?.new_type_suggestion || null\n  },\n  \n  custom_fields: {\n    field_updates: aiResults.custom_fields?.field_updates || {},\n    confidence: Number(aiResults.custom_fields?.confidence) || 0,\n    new_fields_needed: aiResults.custom_fields?.new_fields_needed || []\n  },\n  \n  tags: {\n    existing_tag_names: aiResults.tags?.existing_tag_names || [],\n    new_tags_needed: aiResults.tags?.new_tags_needed || [],\n    confidence: Number(aiResults.tags?.confidence) || 0\n  },\n  \n  processing_notes: String(aiResults.processing_notes || 'Processing completed'),\n  processing_errors: processingErrors,\n  processing_timestamp: new Date().toISOString(),\n  processing_duration_ms: Date.now() - startTime\n};\n\nconsole.log('=== PARSING COMPLETE ===');\nconsole.log(`Document ID: ${documentId}`);\nconsole.log(`Duration: ${sanitizedResults.processing_duration_ms}ms`);\n\nreturn { json: sanitizedResults };"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1632,
        192
      ],
      "id": "d2983366-11d4-452a-82c3-169e444d86fb",
      "name": "Process AI Results"
    },
    {
      "parameters": {
        "jsCode": "// Consolidated Processing - All branches in one node (WITH ENHANCED DATE FIX)\nconsole.log('=== CONSOLIDATED PROCESSOR ===');\nconst processingData = $json;\n\nlet result = {\n  document_id: processingData.document_id,\n  update_payload: {},\n  has_updates: false,\n  processing_summary: {\n    document_type: {},\n    custom_fields: {},\n    tags: {},\n    processing_errors: []\n  },\n  overall_success: false\n};\n\n// ===== DOCUMENT TYPE PROCESSING =====\ntry {\n  const documentTypeData = processingData.document_type;\n\n  if (!documentTypeData) {\n    throw new Error('No document type data found');\n  }\n\n  if (documentTypeData.recommended_id && documentTypeData.confidence > 0.6) {\n    result.update_payload.document_type = documentTypeData.recommended_id;\n    result.has_updates = true;\n    result.processing_summary.document_type = {\n      status: 'updated',\n      type_id: documentTypeData.recommended_id,\n      type_name: documentTypeData.recommended_name,\n      confidence: documentTypeData.confidence,\n      action: 'using_existing_type'\n    };\n    console.log(`‚úÖ Document type: Using \"${documentTypeData.recommended_name}\" (ID: ${documentTypeData.recommended_id})`);\n  } else if (documentTypeData.create_new && documentTypeData.new_type_suggestion) {\n    result.processing_summary.document_type = {\n      status: 'not_updated',\n      reason: 'New document type creation not implemented',\n      new_type_suggestion: documentTypeData.new_type_suggestion\n    };\n    console.log('‚ö†Ô∏è Document type: Needs new type creation (not implemented)');\n  } else {\n    result.processing_summary.document_type = {\n      status: 'not_updated',\n      reason: 'No valid recommendation or confidence too low',\n      confidence: documentTypeData.confidence\n    };\n    console.log('‚ÑπÔ∏è Document type: No update needed');\n  }\n} catch (error) {\n  result.processing_summary.processing_errors.push(`Document Type: ${error.message}`);\n  result.processing_summary.document_type = {\n    status: 'error',\n    error: error.message\n  };\n  console.error('‚ùå Document Type Error:', error.message);\n}\n\n// ===== CUSTOM FIELDS PROCESSING =====\ntry {\n  const customFieldsData = processingData.custom_fields;\n\n  if (!customFieldsData) {\n    throw new Error('No custom fields data found');\n  }\n\n  const fieldUpdates = customFieldsData.field_updates || {};\n  const fieldCount = Object.keys(fieldUpdates).length;\n\n  if (fieldCount > 0 && customFieldsData.confidence > 0.5) {\n    // Validate and process field updates\n    const validUpdates = [];\n    let validFieldCount = 0;\n\n    for (const [fieldId, fieldValue] of Object.entries(fieldUpdates)) {\n      const numericFieldId = parseInt(fieldId);\n      if (!isNaN(numericFieldId) && fieldValue !== null && fieldValue !== '') {\n        let processedValue = String(fieldValue);\n\n        // ===== ENHANCED DATE FIELD HANDLING =====\n        // 1. European format: DD.MM.YYYY ‚Üí YYYY-MM-DD\n        if (/^\\d{2}\\.\\d{2}\\.\\d{4}$/.test(processedValue)) {\n          const parts = processedValue.split('.');\n          const day = parts[0];\n          const month = parts[1];\n          const year = parts[2];\n          processedValue = `${year}-${month}-${day}`;\n          console.log(`üìÖ Field ${numericFieldId}: Converted European date \"${fieldValue}\" ‚Üí \"${processedValue}\"`);\n        }\n        // 2. Partial format: YYYY-MM ‚Üí YYYY-MM-01\n        else if (/^\\d{4}-\\d{2}$/.test(processedValue)) {\n          processedValue = `${processedValue}-01`;\n          console.log(`üìÖ Field ${numericFieldId}: Converted partial date \"${fieldValue}\" ‚Üí \"${processedValue}\"`);\n        }\n        // 3. US format: MM/DD/YYYY ‚Üí YYYY-MM-DD\n        else if (/^\\d{2}\\/\\d{2}\\/\\d{4}$/.test(processedValue)) {\n          const parts = processedValue.split('/');\n          const month = parts[0];\n          const day = parts[1];\n          const year = parts[2];\n          processedValue = `${year}-${month}-${day}`;\n          console.log(`üìÖ Field ${numericFieldId}: Converted US date \"${fieldValue}\" ‚Üí \"${processedValue}\"`);\n        }\n        // 4. Validate it's now in correct YYYY-MM-DD format\n        else if (!/^\\d{4}-\\d{2}-\\d{2}$/.test(processedValue)) {\n          // Check if it looks like a date field but in wrong format\n          if (/\\d{2,4}[.\\-\\/]\\d{1,2}[.\\-\\/]\\d{2,4}/.test(processedValue)) {\n            console.warn(`‚ö†Ô∏è Skipping field ${numericFieldId}: Unrecognized date format \"${fieldValue}\"`);\n            continue;\n          }\n          // Otherwise assume it's a text/number field and keep as-is\n        }\n\n        // Paperless API expects array format: [{\"field\": 21, \"value\": \"...\"}, ...]\n        validUpdates.push({\n          field: numericFieldId,\n          value: processedValue\n        });\n        validFieldCount++;\n      }\n    }\n\n    if (validFieldCount > 0) {\n      result.update_payload.custom_fields = validUpdates;\n      result.has_updates = true;\n      result.processing_summary.custom_fields = {\n        status: 'updated',\n        field_count: validFieldCount,\n        confidence: customFieldsData.confidence\n      };\n      console.log(`‚úÖ Custom fields: Processing ${validFieldCount} field updates (array format)`);\n    } else {\n      result.processing_summary.custom_fields = {\n        status: 'not_updated',\n        reason: 'No valid field updates found'\n      };\n      console.log('‚ö†Ô∏è Custom fields: No valid field updates');\n    }\n  } else {\n    result.processing_summary.custom_fields = {\n      status: 'not_updated',\n      reason: 'No updates needed or confidence too low',\n      confidence: customFieldsData.confidence\n    };\n    console.log('‚ÑπÔ∏è Custom fields: No updates needed');\n  }\n} catch (error) {\n  result.processing_summary.processing_errors.push(`Custom Fields: ${error.message}`);\n  result.processing_summary.custom_fields = {\n    status: 'error',\n    error: error.message\n  };\n  console.error('‚ùå Custom Fields Error:', error.message);\n}\n\n// ===== TAGS PROCESSING =====\ntry {\n  const tagsData = processingData.tags;\n\n  if (!tagsData) {\n    throw new Error('No tags data found');\n  }\n\n  const existingTags = tagsData.existing_tag_names || [];\n  const newTags = tagsData.new_tags_needed || [];\n\n  if (existingTags.length > 0 && tagsData.confidence > 0.5) {\n    // Note: Tag name -> ID resolution would be needed for full implementation\n    result.processing_summary.tags = {\n      status: 'identified',\n      tag_names: existingTags,\n      tag_count: existingTags.length,\n      confidence: tagsData.confidence,\n      note: 'Tag updates identified but name->ID resolution not implemented'\n    };\n    console.log(`‚úÖ Tags: Identified ${existingTags.length} existing tags: [${existingTags.join(', ')}]`);\n  } else if (newTags.length > 0) {\n    result.processing_summary.tags = {\n      status: 'needs_new_tags',\n      new_tags: newTags,\n      note: 'New tag creation not implemented'\n    };\n    console.log(`‚ö†Ô∏è Tags: Needs ${newTags.length} new tags (not implemented)`);\n  } else {\n    result.processing_summary.tags = {\n      status: 'not_updated',\n      reason: 'No valid tag recommendations or confidence too low',\n      confidence: tagsData.confidence\n    };\n    console.log('‚ÑπÔ∏è Tags: No updates needed');\n  }\n} catch (error) {\n  result.processing_summary.processing_errors.push(`Tags: ${error.message}`);\n  result.processing_summary.tags = {\n    status: 'error',\n    error: error.message\n  };\n  console.error('‚ùå Tags Error:', error.message);\n}\n\n// Determine overall success\nconst hasUpdates = Object.keys(result.update_payload).length > 0;\nconst hasNoErrors = result.processing_summary.processing_errors.length === 0;\nresult.overall_success = hasUpdates || hasNoErrors;\n\nresult.processing_timestamp = new Date().toISOString();\nresult.workflow_version = 'refactored-v1.2-enhanced-date-fix';\n\nconsole.log('=== CONSOLIDATED PROCESSING COMPLETE ===');\nconsole.log(`Has updates: ${hasUpdates}`);\nconsole.log(`Errors: ${result.processing_summary.processing_errors.length}`);\nconsole.log(`Overall success: ${result.overall_success}`);\n\nif (result.processing_summary.processing_errors.length > 0) {\n  console.warn('Errors encountered:');\n  result.processing_summary.processing_errors.forEach(error => console.warn(`- ${error}`));\n}\n\nreturn { json: result };\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1408,
        192
      ],
      "id": "07d4abe1-58da-400f-900e-cc7aca32c3f0",
      "name": "Consolidated Processor",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "has-updates-check",
              "leftValue": "={{ $json.has_updates }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ]
        },
        "options": {}
      },
      "id": "a44ab2f4-5ffd-4bbf-adce-9aaa8e75956d",
      "name": "Check if Updates Needed",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -832,
        192
      ]
    },
    {
      "parameters": {
        "method": "PATCH",
        "url": "=https://paperless.zenmedia.live/api/documents/{{ $json.document_id }}/",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.update_payload }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -576,
        96
      ],
      "id": "e1ccef4c-5a44-497a-95c7-fd8a542127eb",
      "name": "Update Document",
      "credentials": {
        "httpHeaderAuth": {
          "id": "GM3oN9AzRgfeA7ZZ",
          "name": "PaperlessAPI"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Final Processing Report Generator\nconst inputData = $input.first()?.json;\n\nif (!inputData) {\n  return {\n    json: {\n      status: 'error',\n      message: 'No input data for final processing',\n      timestamp: new Date().toISOString()\n    }\n  };\n}\n\n// Determine the source of this final processing\nlet processingSummary;\nlet documentId;\nlet finalStatus;\n\n// Check if this came from Update Document (HTTP response) or directly from Consolidated Processor\nconst isHttpResponse = inputData.statusCode !== undefined || inputData.id !== undefined;\n\nif (isHttpResponse) {\n  // This came from an HTTP update request\n  const httpResult = inputData;\n  const isSuccessful = httpResult.statusCode ? (httpResult.statusCode >= 200 && httpResult.statusCode < 300) : (httpResult.id !== undefined);\n  \n  // Get the original processing data from Consolidated Processor\n  const originalData = $('Consolidated Processor').first()?.json;\n  \n  processingSummary = {\n    workflow_path: 'document_updated',\n    document_id: originalData?.document_id || httpResult.id || 'unknown',\n    update_attempted: true,\n    update_successful: isSuccessful,\n    http_status: httpResult.statusCode || 200,\n    processing_summary: originalData?.processing_summary || {},\n    api_response: isSuccessful ? 'Document updated successfully' : `Update failed: HTTP ${httpResult.statusCode}`,\n    update_payload: originalData?.update_payload || {},\n    timestamp: new Date().toISOString()\n  };\n  \n  finalStatus = isSuccessful ? 'completed_with_updates' : 'completed_with_update_error';\n  \n  // Log success or errors\n  if (isSuccessful) {\n    console.log(`‚úÖ Document ${processingSummary.document_id} updated successfully`);\n    console.log('Updates applied:', JSON.stringify(processingSummary.update_payload, null, 2));\n  } else if (httpResult.error) {\n    console.error('Document update failed:', httpResult.error);\n    processingSummary.error_details = httpResult.error;\n  }\n  \n} else {\n  // This came directly from the consolidator (no updates path)\n  processingSummary = {\n    workflow_path: 'no_updates_needed',\n    document_id: inputData.document_id || 'unknown',\n    update_attempted: false,\n    update_successful: null,\n    processing_summary: inputData.processing_summary || {},\n    reason: 'No valid updates identified by AI analysis',\n    timestamp: new Date().toISOString()\n  };\n  \n  finalStatus = inputData.overall_success ? 'completed_no_updates' : 'completed_with_errors';\n  console.log(`‚ÑπÔ∏è Document ${processingSummary.document_id} - No updates needed`);\n}\n\n// Generate final report\nconst finalReport = {\n  status: finalStatus,\n  document_id: processingSummary.document_id,\n  processing_complete: true,\n  ...processingSummary\n};\n\nconsole.log('=== WORKFLOW COMPLETE ===');\nconsole.log(`Final Status: ${finalStatus}`);\nconsole.log(`Document ID: ${processingSummary.document_id}`);\nconsole.log(`Updates Applied: ${processingSummary.update_attempted}`);\n\nreturn { json: finalReport };"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -320,
        192
      ],
      "id": "15320646-190c-4dcf-8316-58791227bddb",
      "name": "Final Processing Report",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "paperless/doc-added",
        "authentication": "headerAuth",
        "options": {
          "responseData": "OK"
        }
      },
      "id": "d241a9f7-a1a4-460f-8344-048734fd422d",
      "name": "Paperless Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -3072,
        192
      ],
      "webhookId": "877dcb88-bcf2-426c-ae08-573105047fc8",
      "credentials": {
        "httpHeaderAuth": {
          "id": "88d4WF3HCiXbAAyJ",
          "name": "n8n_API_Token"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "token-check",
              "leftValue": "d9bf2199-6d52-4c0c-be72-4443cc6c2dea",
              "rightValue": "={{ $json.headers['x-api-key'] }}",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ]
        },
        "options": {}
      },
      "id": "57e80c82-44f9-403d-b4ba-a0997762da00",
      "name": "Validate Webhook Token",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -2848,
        192
      ]
    },
    {
      "parameters": {
        "url": "={{ $json.body.doc_url.replace('/documents/', '/api/documents/') }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {}
      },
      "id": "ecf6d50f-f7b4-4e64-be43-7304f3f20d7b",
      "name": "Fetch Document Content",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [
        -2624,
        192
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "GM3oN9AzRgfeA7ZZ",
          "name": "PaperlessAPI"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Enhanced AI Prompt with Error Handling\nconst inputItems = $input.all();\nlet documentData = null;\nlet customFieldsData = [];\n\n// Find document data with fallbacks\ntry {\n  documentData = inputItems.find(item => item.json && (item.json.content || item.json.title));\n  if (!documentData) {\n    throw new Error('No document data found in inputs');\n  }\n} catch (error) {\n  console.error('Document data error:', error.message);\n  // Create minimal fallback structure\n  documentData = {\n    json: {\n      id: 'unknown',\n      title: 'Unknown Document',\n      content: '',\n      correspondent: 'Unknown',\n      document_type: 'Unknown'\n    }\n  };\n}\n\n// Find custom fields data with fallbacks\ntry {\n  const customFieldsItem = inputItems.find(item => item.json && (Array.isArray(item.json.results) || Array.isArray(item.json)));\n  if (customFieldsItem) {\n    customFieldsData = customFieldsItem.json.results || customFieldsItem.json || [];\n  }\n} catch (error) {\n  console.warn('Custom fields data not found, continuing with empty array');\n  customFieldsData = [];\n}\n\n// Safely extract document properties\nconst documentText = (documentData.json.content || '').substring(0, 2000); // Limit content length\nconst documentTitle = documentData.json.title || 'Untitled Document';\nconst correspondent = documentData.json.correspondent || 'Unknown';\nconst documentType = documentData.json.document_type || 'Unknown';\nconst documentId = documentData.json.id;\n\nif (!documentId || documentId === 'unknown') {\n  console.warn('Document ID is missing or invalid, workflow may have limited functionality');\n}\n\n// Build comprehensive prompt\nconst prompt = `\nAI document analyzer for Paperless-ngx. IMPORTANT: Return valid JSON ONLY.\n\nDocument Information:\n- Title: ${documentTitle}\n- Type: ${documentType} \n- From: ${correspondent}\n- Content Preview: ${documentText}\n- Available Custom Fields: ${customFieldsData.length} fields\n\nINSTRUCTIONS:\n1. Analyze the document content thoroughly\n2. Use available tools to get existing entities (document_types, custom_fields, tags)\n3. Prioritize using existing entities over creating new ones\n4. Return structured JSON with confidence scores\n5. Handle missing data gracefully\n\nOUTPUT REQUIREMENTS:\nReturn a JSON object with this exact structure:\n{\n  \"document_analysis\": {\n    \"confidence\": 0.85,\n    \"category\": \"detected_category\",\n    \"summary\": \"brief_analysis_summary\"\n  },\n  \"document_type\": {\n    \"recommended_id\": 123,\n    \"recommended_name\": \"existing_type_name\",\n    \"confidence\": 0.90,\n    \"create_new\": false,\n    \"new_type_suggestion\": null\n  },\n  \"custom_fields\": {\n    \"field_updates\": {\n      \"123\": \"extracted_value_1\",\n      \"456\": \"extracted_value_2\"\n    },\n    \"confidence\": 0.85,\n    \"new_fields_needed\": []\n  },\n  \"tags\": {\n    \"existing_tag_names\": [\"tag1\", \"tag2\"],\n    \"new_tags_needed\": [],\n    \"confidence\": 0.80\n  },\n  \"processing_notes\": \"Explain decisions and any limitations\"\n}\n\nIMPORTANT:\n- Use get_document_types, get_custom_fields, get_tags tools first\n- Prefer existing entities over creating new ones\n- Include confidence scores for all recommendations\n- Handle errors gracefully in your analysis\n- If you cannot analyze something, explain why in processing_notes\n- Return valid JSON only\n`;\n\nconst result = {\n  ...(documentData.json || {}),\n  ai_prompt: prompt,\n  document_id: documentId,\n  custom_fields_available: customFieldsData.length,\n  processing_context: {\n    has_content: !!(documentData.json.content),\n    has_custom_fields: customFieldsData.length > 0,\n    document_valid: !!(documentId && documentId !== 'unknown')\n  }\n};\n\nconsole.log(`Prepared AI prompt for document ${documentId} with ${customFieldsData.length} custom fields available`);\nreturn { json: result };"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2400,
        192
      ],
      "id": "4e652b75-03e6-4ff9-b5c8-4c0aa596fdc5",
      "name": "Prepare AI Prompt"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "builtInTools": {},
        "options": {
          "maxTokens": 2000,
          "temperature": 0.1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.3,
      "position": [
        -2272,
        416
      ],
      "id": "e342527e-806c-423e-bd9a-580b6e095ce7",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "q2ww8qgWPCMRnlG0",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.ai_prompt }}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3,
      "position": [
        -2192,
        192
      ],
      "id": "b2ccbaf5-f9de-44c8-b8aa-80976def86d6",
      "name": "AI Document Analyzer"
    },
    {
      "parameters": {
        "toolDescription": "Provides document types saved in the system in the Paperless NGX ",
        "url": "=https://paperless.zenmedia.live/api/document_types/",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequestTool",
      "typeVersion": 4.3,
      "position": [
        -2112,
        416
      ],
      "id": "aeebe710-5397-4014-a568-594c628e0ffb",
      "name": "get_document_types",
      "credentials": {
        "httpHeaderAuth": {
          "id": "GM3oN9AzRgfeA7ZZ",
          "name": "PaperlessAPI"
        }
      }
    },
    {
      "parameters": {
        "toolDescription": "Provide the custom_fields saved in the system",
        "url": "=https://paperless.zenmedia.live/api/custom_fields/",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequestTool",
      "typeVersion": 4.3,
      "position": [
        -1920,
        416
      ],
      "id": "3e5a95ce-ef3e-443f-9a8b-ea3fcf2712c7",
      "name": "get_custom_fields",
      "credentials": {
        "httpHeaderAuth": {
          "id": "GM3oN9AzRgfeA7ZZ",
          "name": "PaperlessAPI"
        }
      }
    },
    {
      "parameters": {
        "toolDescription": "Provide the tags saved in the system",
        "url": "=https://paperless.zenmedia.live/api/tags/",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequestTool",
      "typeVersion": 4.3,
      "position": [
        -1792,
        416
      ],
      "id": "bb98df9b-411d-4082-a043-422e05a19b36",
      "name": "get_tags",
      "credentials": {
        "httpHeaderAuth": {
          "id": "GM3oN9AzRgfeA7ZZ",
          "name": "PaperlessAPI"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "41d9541d-b8f5-4fae-a04f-c25e414e79de",
              "name": "document_id",
              "value": "={{ $('Prepare AI Prompt').item.json.id }}",
              "type": "number"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -1840,
        192
      ],
      "id": "0240b434-e5bb-45c6-b34a-fe615a1ef338",
      "name": "Pass Document ID"
    },
    {
      "parameters": {
        "jsCode": "// Validation Failed Handler\nconst result = {\n  status: 'error',\n  error_type: 'authentication_failed',\n  message: 'Invalid webhook token - authentication failed',\n  timestamp: new Date().toISOString(),\n  workflow_terminated: true\n};\n\nconsole.error('‚ùå WORKFLOW TERMINATED: Invalid webhook token');\n\nreturn { json: result };"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2704,
        400
      ],
      "id": "50c0a447-aa91-49a0-9fd6-82540b75e25b",
      "name": "Validation Failed",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Tag Name to ID Mapper - Using AI Agent's Tool Results\nconsole.log('=== TAG NAME TO ID MAPPER (Using AI Tool Data) ===');\n\n// Get the consolidated processing data\nconst consolidatedData = $('Consolidated Processor').first()?.json;\n\nif (!consolidatedData) {\n  throw new Error('No data from Consolidated Processor');\n}\n\n// Try to get tags from AI Agent's tool execution\nlet availableTags = [];\n\ntry {\n  // Access the AI Agent node's execution data\n  const aiAgentNode = $('AI Document Analyzer').first();\n  \n  console.log('AI Agent output keys:', Object.keys(aiAgentNode.json));\n  \n  // Check if tool results are available in the output\n  // The structure might vary, so we'll try multiple paths\n  if (aiAgentNode.json.toolResults) {\n    console.log('Found toolResults in AI Agent output');\n    const tagsToolResult = aiAgentNode.json.toolResults.find(r => r.toolName === 'get_tags');\n    if (tagsToolResult && tagsToolResult.result) {\n      availableTags = JSON.parse(tagsToolResult.result).results || [];\n      console.log('‚úÖ Successfully extracted tags from AI tool results');\n    }\n  } else if (aiAgentNode.json.get_tags) {\n    // Alternative structure\n    availableTags = aiAgentNode.json.get_tags.results || [];\n    console.log('‚úÖ Successfully extracted tags from AI get_tags property');\n  } else {\n    console.log('‚ö†Ô∏è Tool results not found in AI Agent output structure');\n    console.log('Available properties:', JSON.stringify(Object.keys(aiAgentNode.json)));\n  }\n  \n} catch (error) {\n  console.warn('Could not access AI Agent tool results:', error.message);\n}\n\n// Fallback: If we couldn't get tags from AI Agent, we need them from the input\nif (availableTags.length === 0) {\n  console.log('‚ÑπÔ∏è No tags from AI Agent, checking input...');\n  const tagsInput = $input.first()?.json;\n  availableTags = tagsInput?.results || [];\n  \n  if (availableTags.length === 0) {\n    console.warn('‚ö†Ô∏è No tags available - you may need to add \"Fetch Available Tags\" node');\n  }\n}\n\nconsole.log('Available tags in system: ' + availableTags.length);\n\n// Clone the consolidated data\nconst enrichedData = JSON.parse(JSON.stringify(consolidatedData));\n\n// Process tag name to ID mapping\ntry {\n  const tagsData = consolidatedData.processing_summary?.tags;\n  \n  if (!tagsData) {\n    console.log('‚ÑπÔ∏è No tags data to process');\n    return { json: enrichedData };\n  }\n\n  const existingTagNames = tagsData.tag_names || \n                           consolidatedData.tags?.existing_tag_names || \n                           [];\n  \n  console.log('Tag names to map: [' + existingTagNames.join(', ') + ']');\n\n  if (existingTagNames.length > 0 && (tagsData.confidence || 0) > 0.5) {\n    const mappedTags = [];\n    const unmappedTags = [];\n    \n    for (let i = 0; i < existingTagNames.length; i++) {\n      const tagName = existingTagNames[i];\n      const normalizedName = tagName.toLowerCase().trim();\n      \n      // Find matching tag (case-insensitive)\n      let matchedTag = null;\n      for (let j = 0; j < availableTags.length; j++) {\n        if (availableTags[j].name.toLowerCase().trim() === normalizedName) {\n          matchedTag = availableTags[j];\n          break;\n        }\n      }\n      \n      if (matchedTag) {\n        mappedTags.push({\n          id: matchedTag.id,\n          name: matchedTag.name\n        });\n        console.log('‚úÖ Mapped: \"' + tagName + '\" ‚Üí ID ' + matchedTag.id);\n      } else {\n        unmappedTags.push(tagName);\n        console.warn('‚ö†Ô∏è Not found: \"' + tagName + '\"');\n      }\n    }\n\n    if (mappedTags.length > 0) {\n      const tagIds = mappedTags.map(function(t) { return t.id; });\n      \n      enrichedData.update_payload.tags = tagIds;\n      enrichedData.has_updates = true;\n      \n      enrichedData.processing_summary.tags = {\n        status: 'mapped',\n        tag_ids: tagIds,\n        tag_names: mappedTags.map(function(t) { return t.name; }),\n        mapped_count: mappedTags.length,\n        unmapped_tags: unmappedTags,\n        confidence: tagsData.confidence || 0,\n        data_source: availableTags.length > 0 ? 'ai_agent_tools' : 'fallback'\n      };\n      \n      console.log('‚úÖ Successfully mapped ' + mappedTags.length + ' tags to IDs: [' + tagIds.join(', ') + ']');\n      \n      if (unmappedTags.length > 0) {\n        console.warn('‚ö†Ô∏è ' + unmappedTags.length + ' tags could not be mapped: [' + unmappedTags.join(', ') + ']');\n      }\n    } else {\n      enrichedData.processing_summary.tags = {\n        status: 'not_mapped',\n        reason: 'No matching tags found in system',\n        attempted_tags: existingTagNames,\n        available_tags_count: availableTags.length\n      };\n      console.warn('‚ùå No tags could be mapped');\n    }\n  } else {\n    console.log('‚ÑπÔ∏è No tag mapping needed (no tags or confidence too low)');\n  }\n  \n} catch (error) {\n  console.error('‚ùå Tag mapping error:', error.message);\n  enrichedData.processing_summary.processing_errors = \n    enrichedData.processing_summary.processing_errors || [];\n  enrichedData.processing_summary.processing_errors.push('Tag Mapping: ' + error.message);\n  \n  enrichedData.processing_summary.tags = {\n    status: 'error',\n    error: error.message\n  };\n}\n\nconsole.log('=== TAG MAPPING COMPLETE ===');\nconsole.log('Has updates: ' + enrichedData.has_updates);\nconsole.log('Tags in payload: ' + (enrichedData.update_payload.tags ? enrichedData.update_payload.tags.length : 0));\n\nreturn { json: enrichedData };"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1008,
        192
      ],
      "id": "dbd9d036-16da-48c0-9167-7d87fcc3dc0f",
      "name": "Map Tag Names to IDs"
    },
    {
      "parameters": {
        "url": "https://paperless.zenmedia.live/api/tags/",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -1200,
        192
      ],
      "id": "65cdf5da-2582-469d-a572-50e24c842381",
      "name": "Fetch Available Tags",
      "credentials": {
        "httpBearerAuth": {
          "id": "rEDoaHLCEgmFZna6",
          "name": "Paperless"
        },
        "httpHeaderAuth": {
          "id": "GM3oN9AzRgfeA7ZZ",
          "name": "PaperlessAPI"
        }
      }
    }
  ],
  "pinData": {
    "Paperless Webhook": [
      {
        "json": {
          "headers": {
            "host": "n8n.zakitraki.com",
            "user-agent": "python-httpx/0.28.1",
            "content-length": "192",
            "accept": "*/*",
            "accept-encoding": "gzip, deflate, br, zstd",
            "authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJkNmU1ZDQ3NS0zZjRmLTRmOTMtYTRiOS05Mzk1NmI4ZTJiOWMiLCJpc3MiOiJuOG4iLCJhdWQiOiJwdWJsaWMtYXBpIiwiaWF0IjoxNzYxOTIwMjIxLCJleHAiOjE3OTM0MDEyMDB9.IY78_TE4VDrwNhM4bTMj-JCSQ3x2ubVfvIn1N8e9BiY",
            "connection": "keep-alive",
            "content-type": "application/json",
            "x-api-key": "d9bf2199-6d52-4c0c-be72-4443cc6c2dea",
            "x-forwarded-for": "10.10.2.5",
            "x-forwarded-host": "n8n.zakitraki.com",
            "x-forwarded-proto": "https",
            "x-forwarded-server": "zoraxy-8990c893-9419-485c-a8b9-fa912c8a47c2",
            "x-real-ip": "10.10.2.5"
          },
          "params": {},
          "query": {},
          "body": {
            "added": "2025-12-17T22:01:11.296434+01:00",
            "owner": "admin",
            "doc_url": "https://paperless.zenmedia.live/documents/176/",
            "filename": "0000176",
            "correspondent": "Magenta",
            "document_type": "Invoice"
          },
          "webhookUrl": "https://n8n.zakitraki.com/webhook/paperless/doc-added",
          "executionMode": "production"
        },
        "pairedItem": {
          "item": 0
        }
      }
    ]
  },
  "connections": {
    "Process AI Results": {
      "main": [
        [
          {
            "node": "Consolidated Processor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Consolidated Processor": {
      "main": [
        [
          {
            "node": "Fetch Available Tags",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check if Updates Needed": {
      "main": [
        [
          {
            "node": "Update Document",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Final Processing Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Document": {
      "main": [
        [
          {
            "node": "Final Processing Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Paperless Webhook": {
      "main": [
        [
          {
            "node": "Validate Webhook Token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Webhook Token": {
      "main": [
        [
          {
            "node": "Fetch Document Content",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Validation Failed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Document Content": {
      "main": [
        [
          {
            "node": "Prepare AI Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare AI Prompt": {
      "main": [
        [
          {
            "node": "AI Document Analyzer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Document Analyzer": {
      "main": [
        [
          {
            "node": "Pass Document ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pass Document ID": {
      "main": [
        [
          {
            "node": "Process AI Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Document Analyzer",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "get_document_types": {
      "ai_tool": [
        [
          {
            "node": "AI Document Analyzer",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "get_custom_fields": {
      "ai_tool": [
        [
          {
            "node": "AI Document Analyzer",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "get_tags": {
      "ai_tool": [
        [
          {
            "node": "AI Document Analyzer",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Map Tag Names to IDs": {
      "main": [
        [
          {
            "node": "Check if Updates Needed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Available Tags": {
      "main": [
        [
          {
            "node": "Map Tag Names to IDs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "saveDataErrorExecution": "all",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false,
    "saveDataSuccessExecution": "all"
  },
  "versionId": "5cb91d4e-2e1f-4bfa-9ca6-939f0bfa386b",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "585a40e69426ffa79544e8cfdd288c324cb49fec34f1409434a96c937d82eeab"
  },
  "id": "lMYyn3sAUXYKJ8oS",
  "tags": []
}